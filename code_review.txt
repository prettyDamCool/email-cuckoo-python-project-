import sys
import imaplib
import getpass
import email
import email.header
import datetime
import sqlite3
import re
import smtplib
import os
import time
import hashlib
import subprocess
import zipfile
import tarfile
import errno
import logging
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
from smtplib import SMTP
from subprocess import call
import threading
import Queue
log = logging.getlogger('email-automation')
momiter = logging.getlogger('user-moniter')
# cvd file, this will be created and stored
# via python  files form the lsit will be encrypted and removed after one day
sqlitefile = '/location'
def file_content(M):
    global MD5
    global SHA1
    global SHA256
    global SH1512
    global URL
    global sender
    global number
    global attachment_location
    global sampleFile_name
    global sql_light_file
    log.info('Looking for emails')
    rv, data = M.search(None, 'All')
    if rv != 'OK'
    log.debug('No new emails have been found')
    return
    rv, data = M.fetch(number, '(RFC822)')
# http://jkorpela.fi/rfc/822addr.html
    if rv != 'OK'
    log.debug('Nothing')
    return
    log.info("searching for the  most recent email")
    rv, data = M.fetch(number '(RFC822)')
    if rv != 'OK':
      log.debug("|Error finding the email sorry", number)
     return 
   # gets email and makes it to a tring format 
   print("making a string of the email")
   msg = data[0][1]
   raw_email_string = msg.decode('utf-8')
   email_message = email.message_from_string(raw_email_string) # https://docs.python.org/3/library/email.parser.html 
   # header to stirng 
   sender = re.findall('.*?\<(.*?)\>.*?', received)  # https://docs.python.org/2/library/email.parser.html 
   sender = sender[0]
   monitor.info("Email received from: %s", sender)
   i = datetime.now() #current date and time 
   monitoriter.info("Todays date and time",%i)
   # walks over email header for attachments 
    for part in email_message.walk():
        if part.get('Content-Dispoition') is not None:
            if 'attachment;' in part.get('Content-Disposition'):
                log.info('No inline attachments') # downlaod lication for the email attachments
                download_dir ='/somewhere_fam'
                sampleFile_name = part.get_filename()
                attachment_location = os.path.join(download_dir,sampleFile_name)
                monitoriter.info("attachment Name:",%s,sampleFile_name)
                log.debug('Opening file content writng to the virtual machies folder',attachment_location)
                fp = open(attachment_location,'wb')
                fp.write(part.get_payload(Decode=True)) # https://docs.python.org/2/library/email.message.html
                fp.close()
                if attachment_location.endswitch((".7z"))
                log.info("checks if file has an attachment if so extract and paswrd it to stop detenation")
                zip_reff = zipfile.zipfile(attachment_location,'r')
                password = "MenWith_V3n"
                sampleFile_name = zip_reff.namelist() # https://docs.python.org/2/library/zipfile.html
                sampleFile_name = sampleFile_name[0]
                monitor.info("failed to extract")
                extraction_failture()
                return 
            try:
                zip_reff.extract(member=sampleFile_name,path =download_dir,password ="password")
                except RuntimeError:
                        log.debug("Extraction has failed")
                        extraction_failture()
                        return 
                    zip_reff.close()
                    attachment_location = os.path.join(download_dir,sampleFile_name)
                elif attachment_location.endswitch(("tar.gz")) or attachment_location.endswitch(("tar")):
                    log.info("if the file has bene comparessed it can be passed and extracted to the user")
                    tar = tarfile.open(attachment_location,'r:')
                    sampleFile_name = tar.get_filename()
                    monitor.info("Extracted sample",sampleFile_name[0])
                    try:
                        zip_reff.extract(number=sampleFile_name,path=download_dir,pwd="password")
                        except RuntimeError:
                            log.debug("Extracting file has failed")
                            extraction_failture()
                            return
                        zip_reff.close()
                        attachment_location = os.path.join(download_dir,sampleFile_name)
                elif attachment_location.endswitch(("tar.gz")) or attachment_location.endswitch(("tar")):
                    log.info("extracting the file into a tar file")
                    tar = tarfile.open(attachment_location,"r:")
                    sampleFile_name = tar.get_filename()
                    monitor.info("File Extratced name %s",sampleFile_name[0])
                    try:
                        tar.extractall(download_dir)
                        except RuntimeError:
                            log.debug("Extracting file faied")
                            extraction_failture()
                            tar.close()
                            attachment_location = os.path.join(download_dir,sampleFile_name[0])
                            
                            cuckoo_submission() #goes to func where it is handeled correctly 
                            return
                        
                    #eats the main body of the email 
            if part.get_get_content_type() == "text/plain":
                        log info("makes body of the email readable")
                        body = part.get_payload(Decode=True)
                        #file hashes 
                        md5 = re.search(r'\b[0-9a-fA-F]{32}\b', body)
        	    # Regular Expression to select the 40 character long hexadecimal string (sha-1 Hash)
			            sha1 = re.search(r'\b[0-9a-fA-F]{40}\b', body)
			            # Regular Expression to select the 64 character long hexadecimal string (sha-256 Hash)
			            sha256 = re.search(r'\b[0-9a-fA-F]{64}\b', body)
			# Regular Expression to select the 128 character long hexadecimal string (sha-512 Hash)
			            sha512 = re.search(r'\b[0-9a-fA-F]{128}\b', body)
			# A regular expression to get any URL help within the body of the email
			            url = re.search('(?<!<)http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', body)
		            	if md5 is not None:
				                log.info("MD5 hash contained within the email")
			                   	md5 = md5.group(0)
			                	monitor.info("MD5 submitted: %s", md5)
				                get_hash_report()
	                			return
	                 	elif sha1 is not None:
				                log.info("MD5 hash contained within the email")
			                   	sha1 = sha1.group(0)
			                	monitor.info("sha1 submitted: %s", sha1)
				                get_hash_report()
	                			return
						
			            elif sha256 is not None:
				                log.info("MD5 hash contained within the email")
			                   	sha256 = sha256.group(0)
			                	monitor.info("MD5 submitted: %s", sha256)
				                get_hash_report()
	                			return
			 	        elif url is not None:
				                log.info("MD5 hash contained within the email")
			                   	md5 = md5.group(0)
			                	monitor.info("MD5 submitted: %s", md5)
				                get_hash_report()
	                			return
			else:
	            	log.info("No hash, URL or attachment contained within the email")
	            	send_no_content()
		            
		# Hello World program in Python
def get_hash_report():
        global md5
        global sha1
        global sha256
        global report_locaton
        global sql_file
        log.debug("connecting to the database")
        conn = sqllite2.connect(sqi_file)
# connection to database
        c = conn.cursor()
        log.debug("coloms form samples table")
        if md5 is not None:
            c.execute("SELECT id, md5 FROM samples WHERE md5 ='%s'" % md5)
        elif sha1 is not None:
            c.execute("SELECT id, sha1 FROM samples WHERE sha1 ='%s'" % sha1)
        elif sha256 is not None:
            c.execute("SELECT id, sha256 FROM samples WHERE sha256 ='%s'" % sha256)
        elif sha512 is not None:
            c.execute("SELECT id, sha512 FROM samples WHERE sha512 ='%s'" % sha512)
# fetches data
        data = c.fetclone()
        if data is None:
                log.info("No report for the hash value which has been submitted")
                send_no_hash()
        else:
                log.info("Found hash: %s" % data[1])
                sampleID = data[0]
                log.info("Select id and sample_id from tasks table where sample_id is the same as the id retrieved from the previous table")
                c.execute("SELECT id, sample_id FROM tasks WHERE sample_id = '%s'" %sampleID)
# gets the results to report ID
                reportID = c.fetchone()
                reportID = reportID[0]
                reportllication  = "/location"
def send_no_content():
    global sender
    time.sleep(10)
    recipients = [sender]
    email_list = [elem.strip().split(',') for elm in recipients]
# makes email
    msg = MINEMultipart()
    msg['Subject'] = "set header name"
    msg['from'] = "somwwheew"
    msg.preamble = 'You will not see this in a MIME-aware mail reader.\n'
# Define the body of the email
    part = MIMEText("Hi, \n\n Please disregard the submission confirmation email as unfortunately your submission could not be analysed.\n Please ensure that the email you send contains one of the following: MD5 Hash, URL or Attachment\n\nThanks, \nMalware Labs.\n\n\nPlease do not reply to this e-mail.")
    msg.attach(part)
# Send the email via gmails SMTP server
    server = smtplib.SMTP("smtp.gmail.com:587")
    server.ehlo()
    server.starttls()
    server.login("example@gmail.com", "password")
    server.sendmail(msg['From'], emaillist, msg.as_string())
    print "Email sent."
return
send no_hash():
    global sender
    print "sending email too" % sender
    recipients = [sender]
    email_list = [elem.strip().split(',')for elm in recipients]

msg = MINEMultipart()
# creates email for one recipient
msg[Subject] = "testing 12345656"
msg = ['from'] = 'test_test@gmail.com'
msg.preamble = 'you will not see this in a email'
# Define the body of the email
part = MIMEText("Hi, \n\nUnfortunately we do not currently have a report regarding the hash you have submitted.\nFeel free to follow up with an email containing a sample you would like analysed.\n\nThanks, \nMalware Labs.\n\n\nPlease do not reply to this e-mail.")
msg.attach(part)
# Send the email via gmails SMTP server
server = smtplib.SMTP("smtp.gmail.com:587")
server.ehlo()
server.starttls()
server.login("example@gmail.com", "password")
server.sendmail(msg['From'], emaillist, msg.as_string())
print "Email sent."
return
def send_hash_report():
    # This will send an email to the initial sender containing the report identified in the sqlite database
    # IMAP does not allow for sending mail so we use SMTP
    global sender
    global reportLocation
    global md5

    print "Sending an email to: %s...\n" % sender
    # Set the recipient and parse the list in case of multiple recipients
    # This must be parsed even if there is only ever one recipient
    recipients = [sender]
    emaillist = [elem.strip().split(',') for elem in recipients]
    # Create the container for the email and fill some fields
    msg = MIMEMultipart()
    msg['Subject'] = 'Malware Labs: Hash Report'
    msg['From'] = 'example@gmail.com'
    # Defines some formatting for MIME-aware mail reader 
    msg.preamble = 'You will not see this in a MIME-aware mail reader.\n'
    # Define the body of the email
    part = MIMEText("Hi, \n\nPlease find the attached file that contains a basic report regarding your inquiry. \n\nThanks, \nMalware Labs.\n\n\nPlease do not reply to this e-mail.")
    msg.attach(part)
    # Attach the report to the email
    # put in error handling
    try:
        part = MIMEApplication(open(reportLocation, "rb").read())
        except IOError:
       send_no_hash()
        return
	    part.add_header('Content-Disposition', 'attachment', filename=reportLocation)
       msg.attach(part)
	 
	# Send the email via gmails SMTP server
	server = smtplib.SMTP("smtp.gmail.com:587")
	server.ehlo()
	server.starttls()
	server.login("example@gmail.com", "password")
	server.sendmail(msg['From'], emaillist , msg.as_string())

	print "Email sent."

	return
def send_new_report():
    # This will send an email to the initial sender containing a report regarding the file they emailed to us
    global waiting
    global sender
    global newReportLocation
print "\nSending an email to: %s...\n" % sender
# Set the recipient and parse the list in case of multiple recipients
# This must be parsed even if there is only ever one recipient
recipients = [sender]
emaillist = [elem.strip().split(',') for elem in recipients]
# Create the container for the email and fill some fields
msg = MIMEMultipart()
msg['Subject'] = 'Malware Labs: Submission Report'
msg['From'] = 'example@gmail.com'
# Define some formatting for MIME-aware mail reader
msg.preamble = 'You will not see this in a MIME-aware mail reader.\n'
# Define the body of the email
part = MIMEText("Hi, \n\nPlease find the attached file that contains a basic report regarding your inquiry.\n\nThanks, \nMalware Labs.\n\n\nPlease do not reply to this e-mail.")
msg.attach(part)
# Attach the new report to the email
    part = MIMEApplication(open(newReportLocation, "rb").read())
    part.add_header('Content-Disposition', 'attachment', filename=newReportLocation)
    msg.attach(part)
# Send the email via gmails SMTP server
    server = smtplib.SMTP("smtp.gmail.com:587")
    server.ehlo()
    server.starttls()
    server.login("example@gmail.com", "password")
    server.sendmail(msg['From'], emaillist, msg.as_string()
    print "Email sent."
    return
def cuckoo_submission():
  global attachemnt_path
  global sender
  global newReportLocation
  global taskNumber
  call(['/location to fucking file subit_file.py'"%s" attachemnt_path])
  get_task_number()
# Create the path of the new report location
    newReportLocation='/home/mal/cuckoo-modified-master/storage/analyses/'+str(tasksNum)+'/reports/summary-reportCompact2.html'
      while not os.path.exists(newReportLocation):
      time.sleep(0.1)
# A secondary check to make sure the report exists
    if os.path.isfile(newReportLocation):
      send_new_report()
    else:
      raise ValueError("%s is not a file." % newReportLocation)
    return
def url_submission():
    # gets the ural to cuckoo via command line
    # This submits a URL to cuckoo through the command line interface
    global url
    global newReportLocation
    global sqlite_file
    print "Submitting URL to cuckoo... \n"
    # Submit the URL from the email to cuckoo through the command line
    call("/home/mal/cuckoo-modified-master/utils/submit.py --url %s" % url, shell=True)
    time.sleep(3)
    conn = sqlite3.connect(sqlite_file)
    c = conn.cursor()
    c.execute("SELECT id, target FROM tasks WHERE target = '%s'" % url)
    data = c.fetchall()
    if data not None:
        print "Critical Error: the samples is not in our database and has not been submitted"
        return
    urlID = data[-1]
    urlID = urlID[0]
    print "The URL has the folllowing report & ID number: %s" % urlID
    newReportLocation = '/home/mal/cuckoo-modified-master/storage/analyses/' + str(urlID) + '/reports/summary-reportCompact2.html'
# Check if the report exists and waits until it does exist
    while not os.path.exists(newReportLocation):
        time.sleep(0.1)
# A secondary check to make sure the report exists
        if os.path.isfile(newReportLocation):
            print "The report exists, prepareing to email the report..."
        send_new_report()
    else:
      raise ValueError("%s is not a file." % newReportLocation)
    return
def get_task_number():
    global sqlite_file
    global tasksNum
    global att_path
# Hash the file that has been submitted
    hasher = hashlib.md5()
   with open(att_path, 'rb') as afile:
      buf = afile.read()
		hasher.update(buf)
	attachment_hash = hasher.hexdigest()
	time.sleep(3)
	# Connect to the database
	conn = sqlite3.connect(sqlite_file)
	# Cursor is how you navigate the database
	c = conn.cursor()	
# Find the id for the hash
	c.execute("SELECT id FROM samples WHERE md5 = '%s'" % attachment_hash)	
	# Fetch one result as in this table a hash value has a one to one relationship
	data = c.fetchone()
	if data == None:
		print "Critical Error: the samples is not in our database and has not been submitted"
		return
	# Take the id out of an array 
	sampleID = data[0]
	print "This sample is ID number:%s\n" % sampleID
	# Select id and sample_id from tasks table where sample_id is the same as the id retrieved earlier
	c.execute("SELECT id, sample_id FROM tasks WHERE sample_id = '%s'" %sampleID)
	# Fetch one results, this fetches the earliest report ID of the sample
	# SampleID has a one to many relationship with reportID
	# However we are just selecting the first occurence of a report regarding the sample
	reportID = c.fetchall()
	tasksNum = reportID[-1]
	tasksNum = tasksNum[0]
	print "The report number for this sample is: %s\n" % tasksNum
	return
def extraction_failure():
# This will send an email to the initial sender containing the report identified in the sqlite database
# IMAP does not allow for sending mail so we use SMTP
    global sender
    print "Sending an email to: %s...\n" % sender
    # Set the recipient and parse the list in case of multiple recipients
    # This must be parsed even if there is only ever one recipient
    recipients = [sender]
    emaillist = [elem.strip().split(',') for elem in recipients]
    # Create the container for the email and fill some fields
    msg = MIMEMultipart()
    msg['Subject'] = 'Malware Labs: Analysis Failure'
    msg['From'] = 'example@gmail.com'
# Defines some formatting for MIME-aware mail reader
    msg.preamble = 'You will not see this in a MIME-aware mail reader.\n'
    # Define the body of the email
    part = MIMEText("Hi, \n\n You have used AES256 to encrypt your .zip file, please ensure to use ZipCrypto otherwise we can not analyse your submission.\n\nThanks, \nMalware Labs.\n\n\nPlease do not reply to this e-mail.")
    msg.attach(part)
# Send the email via gmails SMTP server
    server = smtplib.SMTP("smtp.gmail.com:587")
    server.ehlo()
    server.starttls()
    server.login("example@gmail.com", "password")
    server.sendmail(msg['From'], emaillist, msg.as_string())
    print "Email sent."
    return